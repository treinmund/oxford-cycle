return(dist_df)
}
# Create distance dataframe for each recording. Trying to create a function that does it all at one time keeps crashing my laptop
recording0 <- tracks_eda[[1]] |>
ungroup() |>
nest(.by = frame) |>
mutate(distance = lapply(data, calculateDistance))
# Use the unnest function to explore the distance data
test <- recording0 |>
unnest(distance) |>
filter(frame == 0) |>
select(-data)
# Plot the distribution of distances between VRUs and non-VRUs
test |>
ggplot(aes(x = distance)) +
geom_histogram(fill = "steelblue", bins = 50) +
theme_minimal() +
labs(x = "Distance", y = "Count", title = "Distribution of distances between VRUs and non-VRUs")
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter, color = distance)) +
geom_point(shape = 15, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = 2, size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), linewidth = 0.5, alpha = 0.5) # Plot line between VRUs and non-VRUs
p + scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU") +
scale_shape_manual(values = c(15, 2))
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter, color = distance)) +
geom_point(shape = 15, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = 2, size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU") +
scale_shape_manual(values = c(15, 2))
ggplotly(p)
shapes <- c("VRU" = 15, "Non-VRU" = 2)
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter, color = distance)) +
geom_point(shape = VRU, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = Non-VRU, size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU") +
scale_shape_manual(name = "Type", values = c(15, 2), labels = c("VRU", "Non-VRU"))
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter, color = distance)) +
geom_point(shape = "VRU", size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = Non-VRU, size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU") +
scale_shape_manual(name = "Type", values = c(15, 2), labels = c("VRU", "Non-VRU"))
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter, color = distance)) +
geom_point(shape = "VRU", size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = "Non-VRU", size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU") +
scale_shape_manual(name = "Type", values = c(15, 2), labels = c("VRU", "Non-VRU"))
p
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter, color = distance)) +
geom_point(shape = "VRU", size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = "Non-VRU", size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU") +
scale_shape_manual(name = "Type", values = shapes)
p
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter, color = distance)) +
geom_point(shape = 15, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = 2, size = 2) + # Plot non-VRUs
geom_curve(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), curvature = 0.2, alpha = 0.5, color = distance) + # Plot curve between VRUs and non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU")
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter, color = distance)) +
geom_point(shape = 15, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = 2, size = 2) + # Plot non-VRUs
geom_curve(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), curvature = 0.2, alpha = 0.5) + # Plot curve between VRUs and non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU")
p
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter, color = distance)) +
geom_point(shape = 15, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = 2, size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU")
p
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter)) +
geom_point(shape = 15, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = 2, size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter, color = as.factor(distance)), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_colour_viridis_c(name = "Distance", option = "D") +
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU")
p
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter)) +
geom_point(shape = 15, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = 2, size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter, color = as.factor(distance)), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_color_manual(name = "Distance", values = rainbow(length(unique(test$distance)))) +  # Add color scale
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU")
p
ggplotly(p)
p <- test |> ggplot(aes(x = vru_xCenter, y = vru_yCenter)) +
geom_point(shape = 15, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = 2, size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter, color = distance), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_color_viridis_c(name = "Distance", option = "D") +  # Add color scale
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU")
ggplotly(p)
createDistancePlot <- function(df) {
df |>
ggplot(aes(x = vru_xCenter, y = vru_yCenter)) +
geom_point(shape = 15, size = 2) + # Plot VRUs
geom_point(aes(x = non_vru_xCenter, y = non_vru_yCenter), shape = 2, size = 2) + # Plot non-VRUs
geom_segment(aes(x = vru_xCenter, y = vru_yCenter, xend = non_vru_xCenter, yend = non_vru_yCenter, color = distance), linewidth = 0.5, alpha = 0.5) + # Plot line between VRUs and non-VRUs
scale_color_viridis_c(name = "Distance", option = "D") +  # Add color scale
labs(x = "X Coordinate", y = "Y Coordinate", title = "Distance between VRUs and non-VRUs", color = "Distance", shape = "VRU")
}
recording0
recording0_plots <- recording0 |>
mutate(plot = lapply(distance, createDistancePlot)) # Create plots for each frame
print(recording0_plots$plot[[1]])
print(recording0_plots$plot[[1:3]])
print(recording0_plots$plot[[1]], recording0_plots$plot[[2]], recording0_plots$plot[[3]], recording0_plots$plot[[4]], recording0_plots$plot[[5]], recording0_plots$plot[[6]], recording0_plots$plot[[7]], recording0_plots$plot[[8]], recording0_plots$plot[[9]], recording0_plots$plot[[10]])
recording0_plots$plot[[1]]
recording0_plots$plot[[1]]
recording0_plots$plot[[2]]
recording0_plots$plot[[3]]
recording0_plots$plot[[1]]
recording0_plots$plot[[2]]
recording0_plots$plot[[3]]
recording0_plots$plot[[4]]
recording0_plots$plot[[5]]
recording0_plots$plot[[6]]
recording0_plots$plot[[7]]
recording0_plots$plot[[8]]
# Plot the distribution of distances between VRUs and non-VRUs
recording0 |>
unnest(distance) |>
select(-data) |>
geom_histogram(fill = "steelblue", bins = 50) +
theme_minimal() +
labs(x = "Distance", y = "Count", title = "Distribution of distances between VRUs and non-VRUs")
# Plot the distribution of distances between VRUs and non-VRUs
recording0 |>
unnest(distance) |>
select(-data) |>
ggplot(aes(x = distance)) +
geom_histogram(fill = "steelblue", bins = 50) +
theme_minimal() +
labs(x = "Distance", y = "Count", title = "Distribution of distances between VRUs and non-VRUs")
#| output: false
# Import libraries
library(tidyverse)
library(here)
library(plotly)
#library(caret)
#library(ggthemes)
#library(cowplot)
#| output: false
#| eval: false
#| echo: false
# Set file paths
here::i_am("uniD-EDA/uniD-EDA.qmd")
input_path <- paste0(here(), "/data/")
tracks_files <- list.files(input_path, pattern = "*_tracks.csv", full.names = TRUE)
tracks_meta_files <- list.files(input_path, pattern = "*_tracksMeta.csv", full.names = TRUE)
recording_meta_files <- list.files(input_path, pattern = "*_recordingMeta.csv", full.names = TRUE)
# Read csv files
tracks_dfs <- map(tracks_files, read_csv, show_col_types = FALSE)
tracks_meta_dfs <- map(tracks_meta_files, read_csv, show_col_types = FALSE)
# Define column subset for analysis
eda_cols = c("recordingId",
"trackId",
"frame",
"trackLifetime",
"xCenter",
"yCenter",
"width",
"length",
"xVelocity",
"yVelocity",
"latVelocity",
"lonVelocity"
)
# Prepare the data by selecting a subset of rows and merging with class labels
prepare_data <- function(tracks, meta_data) {
tracks |>
select(all_of(eda_cols)) |>
as_tibble() |>
left_join(select(meta_data, trackId, class), by = 'trackId')
}
map2(tracks_dfs, tracks_meta_dfs, prepare_data) -> tracks_dfs
calculateRotatingBoundingBox <- function(x_center, y_center, width, length, angle = 45) {
# Convert the rotation angle to radians. Angle is 45 degrees from image.
angle_rad <- angle * (pi / 180)
# Calculate half the width and half the length
half_width <- width / 2
half_length <- length / 2
# Calculate the coordinates of the bounding box corners
x_cos <- half_length * cos(angle_rad)
x_sin <- half_width * sin(angle_rad)
y_cos <- half_length * sin(angle_rad)
y_sin <- half_width * cos(angle_rad)
x_min <- x_center - x_cos - y_sin
x_max <- x_center + x_cos - y_sin
y_min <- y_center - x_sin + y_cos
y_max <- y_center + x_sin + y_cos
# Return the bounding box coordinates as a list
return(list(x_min = x_min, x_max = x_max, y_min = y_min, y_max = y_max))
}
calculateOrientation <- function(x_min, x_max, y_min, y_max) {
# Calculate the center point of the bounding box
x_center <- (x_min + x_max) / 2
y_center <- (y_min + y_max) / 2
# Calculate the orientation as the arctangent of the box's side
orientation_rad <- atan2(y_max - y_min, x_max - x_min)
# Convert the orientation angle to degrees
orientation_deg <- orientation_rad * (180 / pi)
# Return the orientation angle in degrees and the center point coordinates
return(list(orientation_deg = orientation_deg, x_center = x_center, y_center = y_center))
}
calculateDirection <- function(delta_x, delta_y) {
# Calculate the direction angle in radians
direction_rad <- atan2(delta_y, delta_x)
# Convert the direction angle to degrees
direction_deg <- direction_rad * (180 / pi)
# Return the direction angle in degrees
return(direction_deg)
}
# Calculate the change in x and y position across each frame
calculatePositionChange <- function(df) {
df |>
group_by(trackId) |>
mutate(
delta_x = lag(xCenter) - xCenter,
delta_y = lag(yCenter) - yCenter,
# Replace NA from first observation with 0
delta_x = coalesce(delta_x, 0),
delta_y = coalesce(delta_y, 0)
)
}
# Calculate position change for each track
tracks_dfs <- lapply(tracks_dfs, calculatePositionChange)
# Calculate the orientation, direction, and area of each object
tracks_eda <- lapply(tracks_dfs, function(df) {
df |>
mutate(
mVelocity = sqrt(xVelocity^2 + yVelocity^2),
orientation = calculateOrientation(calculateRotatingBoundingBox(xCenter, yCenter, width, length)$x_min,
calculateRotatingBoundingBox(xCenter, yCenter, width, length)$x_max,
calculateRotatingBoundingBox(xCenter, yCenter, width, length)$y_min,
calculateRotatingBoundingBox(xCenter, yCenter, width, length)$y_max
)$orientation_deg,
direction = calculateDirection(delta_x, delta_y),
area = width * length
) |>
# Adjust the direction angle to be between 0 and 360 degrees
mutate(
direction = case_when(direction < 0 ~ direction + 360,
direction >= 0 ~ direction)
)
})
# Create binary variable for Vulnerable Road Users (VRU)
tracks_eda <- lapply(tracks_eda, function(df) {
df |>
mutate(
VRU = case_when(class == "pedestrian" ~ 1,
class == "bicycle" ~ 1,
class == "animal" ~ 1,
class == "motorcycle" ~ 1,
class == "car" ~ 0,
class == "bus" ~ 0,
class == "truck" ~ 0,
class == "trailer" ~ 0,
class == "van" ~ 0
)
)
}
)
# Create intervals based on frames
interval_length <- 2000
table(cut_interval(1:100), 10)
table(cut_interval(1:100), length = 10)
table(cut_interval(1:100), n = 10)
table(cut_interval(1:100), length = 10, breaks = 2)
table(cut_interval(1:100), width = 10, breaks = 2)
tracks_eda[[1]] |> cut_interval(length = 2000, boundary = 0)
tracks_eda[[1]] |> cut_interval(frame, length = 2000, boundary = 0)
tracks_eda[[1]] |> cut_interval(frame, length = 2000, boundary = 0)
cut_interval(tracks_eda[[1]]$frame)
cut_interval(tracks_eda[[1]]$frame, n = 100)
cut_interval(tracks_eda[[1]]$frame, length = 1000)
# Create intervals based on frames
interval_length <- 2000
tracks_eda_int <- lapply(tracks_eda, function(df) {
df |>
mutate(
interval = cut_interval(frame, length = interval_length, boundary = 0)
)
})
tracks_eda_int[[2]]$interval |> unique()
tracks_eda_int[[1]]$interval |> unique()
# Count the number of classes per interval
tracks_eda_int[[2]] |>
ungroup() |>
select(trackId, interval, class)
# Count the number of classes per interval
tracks_eda_int[[2]] |>
ungroup() |>
select(trackId, interval, class) |>
distinct()
# Count the number of classes per interval
tracks_eda_int[[2]] |>
ungroup() |>
select(trackId, interval, class) |>
distinct() |>
arrange(interval)
# Count the number of classes per interval
tracks_eda_int[[2]] |>
ungroup() |>
select(trackId, interval, class) |>
distinct() |>
group_by(interval, class) |>
summarise(
count = n()
)
# Count the number of classes per interval
interval_dfs <- lapply(tracks_eda_int, function(df) {
df |>
ungroup() |>
select(trackId, interval, class) |>
distinct() |>
group_by(interval, class) |>
summarise(
count = n()
)
})
interval_dfs[[1]]
interval_dfs |>
lapply(function(df) {
df |>
ggplot() +
geom_col(aes(interval, count), position = "dodge") +
scale_x_discrete(labels = c(1:interval_length)) +
facet_wrap(vars(class)) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
})
install.packages("stats")
#| output: false
# Import libraries
library(tidyverse)
library(here)
library(plotly)
library(stats)
#library(caret)
#library(ggthemes)
#library(cowplot)
#| output: false
#| eval: false
#| echo: false
# Set file paths
here::i_am("uniD-EDA/uniD-EDA.qmd")
input_path <- paste0(here(), "/data/")
tracks_files <- list.files(input_path, pattern = "*_tracks.csv", full.names = TRUE)
tracks_meta_files <- list.files(input_path, pattern = "*_tracksMeta.csv", full.names = TRUE)
recording_meta_files <- list.files(input_path, pattern = "*_recordingMeta.csv", full.names = TRUE)
# Read csv files
tracks_dfs <- map(tracks_files, read_csv, show_col_types = FALSE)
tracks_meta_dfs <- map(tracks_meta_files, read_csv, show_col_types = FALSE)
# Define column subset for analysis
eda_cols = c("recordingId",
"trackId",
"frame",
"trackLifetime",
"xCenter",
"yCenter",
"width",
"length",
"xVelocity",
"yVelocity",
"latVelocity",
"lonVelocity"
)
# Prepare the data by selecting a subset of rows and merging with class labels
prepare_data <- function(tracks, meta_data) {
tracks |>
select(all_of(eda_cols)) |>
as_tibble() |>
left_join(select(meta_data, trackId, class), by = 'trackId')
}
map2(tracks_dfs, tracks_meta_dfs, prepare_data) -> tracks_dfs
calculateRotatingBoundingBox <- function(x_center, y_center, width, length, angle = 45) {
# Convert the rotation angle to radians. Angle is 45 degrees from image.
angle_rad <- angle * (pi / 180)
# Calculate half the width and half the length
half_width <- width / 2
half_length <- length / 2
# Calculate the coordinates of the bounding box corners
x_cos <- half_length * cos(angle_rad)
x_sin <- half_width * sin(angle_rad)
y_cos <- half_length * sin(angle_rad)
y_sin <- half_width * cos(angle_rad)
x_min <- x_center - x_cos - y_sin
x_max <- x_center + x_cos - y_sin
y_min <- y_center - x_sin + y_cos
y_max <- y_center + x_sin + y_cos
# Return the bounding box coordinates as a list
return(list(x_min = x_min, x_max = x_max, y_min = y_min, y_max = y_max))
}
calculateOrientation <- function(x_min, x_max, y_min, y_max) {
# Calculate the center point of the bounding box
x_center <- (x_min + x_max) / 2
y_center <- (y_min + y_max) / 2
# Calculate the orientation as the arctangent of the box's side
orientation_rad <- atan2(y_max - y_min, x_max - x_min)
# Convert the orientation angle to degrees
orientation_deg <- orientation_rad * (180 / pi)
# Return the orientation angle in degrees and the center point coordinates
return(list(orientation_deg = orientation_deg, x_center = x_center, y_center = y_center))
}
calculateDirection <- function(delta_x, delta_y) {
# Calculate the direction angle in radians
direction_rad <- atan2(delta_y, delta_x)
# Convert the direction angle to degrees
direction_deg <- direction_rad * (180 / pi)
# Return the direction angle in degrees
return(direction_deg)
}
# Calculate the change in x and y position across each frame
calculatePositionChange <- function(df) {
df |>
group_by(trackId) |>
mutate(
delta_x = lag(xCenter) - xCenter,
delta_y = lag(yCenter) - yCenter,
# Replace NA from first observation with 0
delta_x = coalesce(delta_x, 0),
delta_y = coalesce(delta_y, 0)
)
}
# Calculate position change for each track
tracks_dfs <- lapply(tracks_dfs, calculatePositionChange)
# Calculate the orientation, direction, and area of each object
tracks_eda <- lapply(tracks_dfs, function(df) {
df |>
mutate(
mVelocity = sqrt(xVelocity^2 + yVelocity^2),
orientation = calculateOrientation(calculateRotatingBoundingBox(xCenter, yCenter, width, length)$x_min,
calculateRotatingBoundingBox(xCenter, yCenter, width, length)$x_max,
calculateRotatingBoundingBox(xCenter, yCenter, width, length)$y_min,
calculateRotatingBoundingBox(xCenter, yCenter, width, length)$y_max
)$orientation_deg,
direction = calculateDirection(delta_x, delta_y),
area = width * length
) |>
# Adjust the direction angle to be between 0 and 360 degrees
mutate(
direction = case_when(direction < 0 ~ direction + 360,
direction >= 0 ~ direction)
)
})
# Create binary variable for Vulnerable Road Users (VRU)
tracks_eda <- lapply(tracks_eda, function(df) {
df |>
mutate(
VRU = case_when(class == "pedestrian" ~ 1,
class == "bicycle" ~ 1,
class == "animal" ~ 1,
class == "motorcycle" ~ 1,
class == "car" ~ 0,
class == "bus" ~ 0,
class == "truck" ~ 0,
class == "trailer" ~ 0,
class == "van" ~ 0
)
)
}
)
interval_length <- 2000
# There is variation among the number of frames per recording.
# This creates a set number of frames per interval.
tracks_eda_int <- lapply(tracks_eda, function(df) {
df |>
mutate(
interval = cut_interval(frame, length = interval_length, boundary = 0)
)
})
xtabs(~ interval + class, data = tracks_eda_int[[1]])
tracks_eda_int[[1]] |>
ungroup() |>
select(trackId, interval, class)|>
distinct() |>
xtabs(~ interval + class, data = tracks_eda_int[[1]])
tracks_eda_int[[1]] |>
ungroup() |>
select(trackId, interval, class)|>
distinct() |>
xtabs(~ interval + class, data = .)
tracks_eda_int[[1]] |>
ungroup() |>
select(trackId, interval, class)|>
distinct() |>
xtabs(~ interval + class)
tracks_eda_int[[1]] |>
ungroup() |>
select(trackId, interval, class)|>
distinct()
test <- tracks_eda_int[[1]] |>
ungroup() |>
select(trackId, interval, class)|>
distinct()
xtabs(~ interval + class, data = test)
