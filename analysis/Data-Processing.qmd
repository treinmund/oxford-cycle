---
title: "Data Processing"
format: html
---

# Set-up

## Load Packages

```{r}
# Load required packages. If a package is missing, install it first.
packages <- c("tidyverse", "lubridate", "keyring", "tidygeocoder", "sf", "ggmap")

# Install missing packages
missing_packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(missing_packages)) install.packages(missing_packages)

# Load all packages
lapply(packages, library, character.only = TRUE)
```

## Set File Paths

```{r}
# Define input, output, and figure directories for reproducibility
# Ensure these directories exist before running the script

in_path <- "../input/"     # Path to input data files
out_path <- "../results/"  # Path to save results
fig_path <- "../figures/"  # Path to save figures
```


## Traffic Severity Measures

```{r}
## Traffic Delay Ratio (TDR)
### Argument: duration with traffic, free flow duration
### Returns: percentage increase in travel time due to traffic
### Source: 
traffic_delay_ratio <- function(traffic_duration_min, duration) {
  ((traffic_duration_min - duration) / duration) * 100
}

## Travel Time Index (TTI)
### Argument: duration with traffic, free flow duration
### Returns: quantity that compares travel conditions with and without traffic
### Source: https://www.bts.gov/content/travel-time-index
travel_time_index <- function(traffic_duration_min, duration) {
  traffic_duration_min / duration
}
```


# Data Processing

## Load Data

```{r}
# Load the traffic data
north_files <- list.files(paste0(out_path, "pre-processed/round1"), pattern = "north", full.names = TRUE, ignore.case = TRUE)
central_files <- list.files(paste0(out_path, "pre-processed/round1"), pattern = "south", full.names = TRUE, ignore.case = TRUE)
south_files <- list.files(paste0(out_path, "pre-processed/round1"), pattern = "east", full.names = TRUE, ignore.case = TRUE)

north_dfs <- map(north_files, read_rds)
central_dfs <- map(central_files, read_rds)
south_dfs <- map(south_files, read_rds)

north_df <- bind_rows(north_dfs)
central_df <- bind_rows(central_dfs)
south_df <- bind_rows(south_dfs)

full_df <- bind_rows(north_df, central_df, south_dfs)

# Check for missing values
full_df |>
  select(traffic_duration_min, distance_meters, duration) |>
  map_dbl(~sum(is.na(.)))

# Show rows with missing values
full_df |>
  filter(is.na(traffic_duration_min) | is.na(distance_meters) | is.na(duration))
```

```{r}
# Select relevant dates
dates <- seq(as.Date("2024-10-29"), as.Date("2024-11-21"), by = "day") |>
  as.character()

weekends <- c("2024-11-02", "2024-11-03", "2024-11-09", "2024-11-10", "2024-11-16", "2024-11-17")

dates <- dates[!dates %in% weekends]

# Filter dates on which trials were run
traffic_df <- full_df |>
  filter(date %in% dates) 
```


## Check for data collection errors

```{r}
# Change estimated values to NA for pedestrian routes
traffic_df <- traffic_df |>
  mutate(
    traffic_duration_min = case_when(
      pedestrian == 1 ~ NA_real_,
      TRUE ~ traffic_duration_min
    ),
    distance_meters = case_when(
      pedestrian == 1 ~ NA_real_,
      TRUE ~ distance_meters
    ),
    duration = case_when(
      pedestrian == 1 ~ NA_real_,
      TRUE ~ duration
    )
  )
```



```{r}
# Check for potential errors of non-pedestrian routes generated by API by calculating difference between expected and actual distance
traffic_df <- traffic_df |>
  mutate(
    distance_diff = abs(distance_meters - expected_distance_meters),
    distance_diff = case_when(
      pedestrian == 1 ~ 0, # Set distance difference to 0 for pedestrian routes
      TRUE ~ distance_diff
    )
  )

# Plot histogram of errors for non-pedestrian routes
traffic_df |>
  filter(pedestrian != 1) |>
  ggplot(aes(distance_diff)) +
  geom_histogram(bins = 20, fill = "skyblue", color = "black") +
  labs(title = "Distribution of Distance Differences",
       x = "Distance Difference (meters)",
       y = "Frequency") +
  facet_wrap(~route, scales = "free")
```



```{r}
# Find outliers of difference in expected and estimated distance

# Find the upper percentile of distance difference for each route
upper_bound <- traffic_df |>
  group_by(route) |>
  summarise(upper_quantile = quantile(distance_diff, probs = 0.95, na.rm = TRUE))

# If the distance difference is greater than the upper bound, it is likely that the route is incorrect.
# These will be changes to NAs

traffic_df <- traffic_df |>
  left_join(upper_bound, by = "route") |>
  mutate(
    traffic_duration_min = case_when(
      distance_diff >= upper_quantile ~ NA_real_,
      TRUE ~ traffic_duration_min
    ),
    
    distance_meters = case_when(
      distance_diff >= upper_quantile ~ NA_real_,
      TRUE ~ distance_meters
    ),
    
    duration = case_when(
      distance_diff >= upper_quantile ~ NA_real_,
      TRUE ~ duration
    )
  )

# Check for missing values
traffic_df |>
  select(traffic_duration_min, distance_meters, duration) |>
  map_dbl(~sum(is.na(.)))

# Find roads with missing values
traffic_df |>
  group_by(route, road, pedestrian) |>
  summarise(
    sum_NAs = sum(is.na(traffic_duration_min) | is.na(distance_meters) | is.na(duration)),
    sum_Available = sum(!is.na(traffic_duration_min) & !is.na(distance_meters) & !is.na(duration))
  )
```

## Calculate Travel Time Index

```{r}
# Calculate travel time index
traffic_df <- traffic_df |>
  mutate(
    travel_time_index = travel_time_index(traffic_duration_min, duration),
  )
```


## Merge Geocoded Data


```{r}
# Load geocoded route data
geocoded_route_data <- read_rds(paste0(out_path, "processed/", "geocoded_route_data.rds"))

# Merge geocoded data with the traffic data
geo_codes <- geocoded_route_data |>
  select(origin, destination, start_geocode, end_geocode)


traffic_df <- traffic_df |>
  left_join(geo_codes, by = c("origin" = "origin", "destination" = "destination"))
```


```{r}
# Check for missing values
traffic_df |>
  select(start_geocode, end_geocode) |>
  map_dbl(~sum(is.na(.)))

# Remove rows with missing values
traffic_df <- traffic_df |>
  filter(!is.na(start_geocode$lat) | !is.na(end_geocode$lat) | !is.na(start_geocode$lon) | !is.na(end_geocode$lon))
```


```{r}
traffic_sf <- traffic_df |>
  rowwise() |>
  mutate(
    geometry = st_sfc(st_linestring(matrix(c(start_geocode$lon, start_geocode$lat,
                                             end_geocode$lon, end_geocode$lat), ncol = 2, byrow = TRUE)),
                      crs = 4326)) |>
  ungroup() |>
  st_as_sf()

# Check the structure of the spatial data
plot(st_geometry(traffic_sf))  # Quick visualization
```


```{r}
# Save the geocoded data
write_rds(traffic_sf, paste0(out_path, "processed/", "geocoded_traffic.rds"))
```

